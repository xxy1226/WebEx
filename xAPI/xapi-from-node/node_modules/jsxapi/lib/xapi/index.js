'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('events');

var _log = require('../log');

var _log2 = _interopRequireDefault(_log);

var _rpc = require('./rpc');

var rpc = _interopRequireWildcard(_rpc);

var _normalizePath = require('./normalizePath');

var _normalizePath2 = _interopRequireDefault(_normalizePath);

var _feedback = require('./feedback');

var _feedback2 = _interopRequireDefault(_feedback);

var _components = require('./components');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * User-facing API towards the XAPI. Requires a backend for communicating
 * with an XAPI instance. It should be possible to write backends for all kinds
 * of transports (TSH over SSH, Websockets, HTTP, plain sockets, etc.)
 *
 * @example <caption>Initialization</caption>
 * const xapi = new XAPI(backend);
 *
 * @example <caption>Invoke commands</caption>
 * xapi
 *   .command('Dial', { Number: 'johndoe@example.com' })
 *   .then(onSuccess, onFailure);
 *
 * @example <caption>Fetch a status</caption>
 * xapi
 *   .status.get('Audio Volume')
 *   .then((value) => { console.log(value); });
 *
 * @example <caption>Set a configuration</caption>
 * xapi
 *   .config.set('Audio DefaultVolume', 100);
 *
 * @example <caption>Listen to an event</caption>
 * xapi.event.on('Some Event Name', (data) => {
 *   console.log(`Received feedback data: ${data}`);
 * });
 */
var XAPI = function (_EventEmitter) {
  _inherits(XAPI, _EventEmitter);

  /**
   * @param {Backend} backend - Backend connected to an XAPI instance.
   * @param {object} options - XAPI object options.
   * @param {function} options.feedbackInterceptor - Feedback interceptor.
   */
  function XAPI(backend) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, XAPI);

    /** @type {Backend} */
    var _this = _possibleConstructorReturn(this, (XAPI.__proto__ || Object.getPrototypeOf(XAPI)).call(this));

    _this.backend = backend;

    /** @ignore */
    _this.requestId = 1;

    /** @ignore */
    _this.requests = {};

    /**
     * Interface to XAPI feedback registration.
     * @type {Feedback}
     */
    _this.feedback = new _feedback2.default(_this, options.feedbackInterceptor);

    /**
     * Interface to XAPI configurations.
     * @type {Config}
     */
    _this.config = new _components.Config(_this);

    /**
     * Interface to XAPI events.
     * @type {Event}
     */
    _this.event = new _components.Event(_this);

    /**
     * Interface to XAPI statuses.
     * @type {Status}
     */
    _this.status = new _components.Status(_this);

    // Restrict object mutation
    Object.defineProperties(_this, {
      config: { writable: false },
      event: { writable: false },
      feedback: { writable: false },
      status: { writable: false }
    });
    Object.seal(_this);

    backend.on('close', function () {
      _this.emit('close');
    }).on('error', function (error) {
      _this.emit('error', error);
    }).on('ready', function () {
      _this.emit('ready');
    }).on('data', _this.handleResponse.bind(_this));
    return _this;
  }

  /**
   * Close the XAPI connection.
   *
   * @return {XAPI} - XAPI instance..
   */


  _createClass(XAPI, [{
    key: 'close',
    value: function close() {
      this.backend.close();
      return this;
    }

    /**
     * Executes the command specified by the given path.
     *
     * @example
     * // Space delimited
     * xapi.command('Presentation Start');
     *
     * // Slash delimited
     * xapi.command('Presentation/Start');
     *
     * // Array path
     * xapi.command(['Presentation', 'Start']);
     *
     * // With parameters
     * xapi.command('Presentation Start', { PresentationSource: 1 });
     *
     * // Multi-line
     * xapi.command('UserInterface Extensions Set', { ConfigId: 'example' }, `
     *  <Extensions>
     *    <Version>1.1</Version>
     *    <Panel item="1" maxOccurrence="n">
     *      <Icon>Lightbulb</Icon>
     *      <Type>Statusbar</Type>
     *      <Page item="1" maxOccurrence="n">
     *        <Name>Foo</Name>
     *        <Row item="1" maxOccurrence="n">
     *          <Name>Bar</Name>
     *          <Widget item="1" maxOccurrence="n">
     *            <WidgetId>widget_3</WidgetId>
     *            <Type>ToggleButton</Type>
     *          </Widget>
     *        </Row>
     *      </Page>
     *    </Panel>
     *  </Extensions>
     * `);
     *
     * @param {Array|string} path - Path to command node.
     * @param {Object} [params] - Object containing named command arguments.
     * @param {string} [body] - Multi-line body for commands requiring it.
     * @return {Promise} - Resolved with the command response when ready.
     */

  }, {
    key: 'command',
    value: function command(path, params, body) {
      var apiPath = (0, _normalizePath2.default)(path).join('/');
      var method = 'xCommand/' + apiPath;
      var executeParams = body === undefined ? params : Object.assign({ body: body }, params);
      return this.execute(method, executeParams);
    }

    /** @private */

  }, {
    key: 'handleResponse',
    value: function handleResponse(response) {
      var id = response.id,
          method = response.method;

      if (method === 'xFeedback/Event') {
        _log2.default.debug('feedback:', response);
        this.feedback.dispatch(response.params);
      } else {
        if ({}.hasOwnProperty.call(response, 'result')) {
          _log2.default.debug('result:', response);
          var resolve = this.requests[id].resolve;

          resolve(response.result);
        } else {
          _log2.default.debug('error:', response);
          var reject = this.requests[id].reject;

          reject(response.error);
        }
        delete this.requests[id];
      }
    }

    /** @private */

  }, {
    key: 'nextRequestId',
    value: function nextRequestId() {
      var requestId = this.requestId;
      this.requestId += 1;
      return requestId.toString();
    }

    /**
     * Execute the given JSON-RPC request on the backend.
     *
     * @example
     * xapi.execute('xFeedback/Subscribe', {
     *   Query: ['Status', 'Audio'],
     * });
     *
     * @param {String} method - Name of RPC method to invoke.
     * @param {Object} [params] - Parameters to add to the request.
     * @return {Promise} - Resolved with the command response.
     */

  }, {
    key: 'execute',
    value: function execute(method, params) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        var id = _this2.nextRequestId();
        var request = rpc.createRequest(id, method, params);
        _this2.backend.execute(request);
        _this2.requests[id] = { resolve: resolve, reject: reject };
      });
    }
  }]);

  return XAPI;
}(_events.EventEmitter);

exports.default = XAPI;