'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FeedbackGroup = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('events');

var _log = require('../log');

var _log2 = _interopRequireDefault(_log);

var _normalizePath = require('./normalizePath');

var _normalizePath2 = _interopRequireDefault(_normalizePath);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Group feedback deregister handlers for bookkeeping.
 */
var FeedbackGroup = exports.FeedbackGroup = function () {
  function FeedbackGroup(handlers) {
    _classCallCheck(this, FeedbackGroup);

    this.handlers = handlers;
  }

  /**
   * Add a deregister handler function to the feedback group.
   *
   * @param {function()} handler - Handler to add to the group.
   * @return {FeedbackGroup} - this for chaining.
   */


  _createClass(FeedbackGroup, [{
    key: 'add',
    value: function add(handler) {
      this.handlers.push(handler);
      return this;
    }

    /**
     * Remove a deregister handler function from the feedback group.
     *
     * @param {function()} handler - Handler to remove from the group.
     * @return {FeedbackGroup} - this for chaining.
     */

  }, {
    key: 'remove',
    value: function remove(handler) {
      this.handlers = this.handlers.filter(function (h) {
        return h !== handler;
      });
      return this;
    }

    /**
     * Call the deregister handler functions associated with this group.
     *
     * @return {FeedbackGroup} - this for chaining.
     */

  }, {
    key: 'off',
    value: function off() {
      this.handlers.forEach(function (handler) {
        handler();
      });
      this.handlers = [];
      return this;
    }
  }]);

  return FeedbackGroup;
}();

function defaultInterceptor(payload, emit) {
  emit(payload);
}

function _dispatch(feedback, data) {
  var root = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : data;
  var path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

  if (Array.isArray(data)) {
    data.forEach(function (child) {
      _dispatch(feedback, child, root, path);
      _dispatch(feedback, child, root, path.concat(child.id));
    });
    return;
  }

  var emitPath = path.join('/').toLowerCase();
  feedback.eventEmitter.emit(emitPath, data, root);

  if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
    Object.keys(data).forEach(function (key) {
      _dispatch(feedback, data[key], root, path.concat(key));
    });
  }
}

/**
 * Feedback handler for the XAPI.
 *
 * @example <caption>Register a feedback listener</caption>
 * xapi.feedback.on('Status/Audio/Volume', data => {
 *   console.log(`Received feedback data: ${data}`);
 * });
 *
 * @example <caption>Get the feedback root payload</caption>
 * xapi.feedback.on('Status/Audio/Volume', (data, payload) => {
 *   console.log(`System volume changed to: ${data}`);
 *   JSON.stringify(payload) // => { Status: { Audio: { Volume: data } } }
 * });
 *
 * @example <caption>Listen to array elements</caption>
 * xapi.feedback.on('Status/Call[42]/Status', callStatus => {
 *   console.log(`Call status for call number 42 is: ${callStatus}`);
 * });
 *
 * @example <caption>Bundle feedback listeners for easy unsubscription</caption>
 * const feedbackGroup = xapi.feedback.group([
 *   xapi.status.on('Audio/Volume', volumeListener),
 *   xapi.status.on('Call', callListener),
 * ]);
 *
 * // Disable feedback listening for all listeners of the group.
 * feedbackGroup.off();
 *
 * @example <caption>Register listener with Array path</caption>
 * const off = xapi.feedback.on('Status/Audio/Volume', listener);
 * off(); // De-register feedback
 */

var Feedback = function () {
  /**
   * @param {XAPI} xapi - XAPI instance.
   * @param {function} interceptor - Feedback interceptor.
   */
  function Feedback(xapi) {
    var interceptor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultInterceptor;

    _classCallCheck(this, Feedback);

    Object.defineProperties(this, {
      eventEmitter: { value: new _events.EventEmitter() },
      interceptor: { value: interceptor },
      xapi: { value: xapi },
      subscriptions: { value: [], writable: true }
    });
  }

  /**
   * Registers a feedback listener with the backend service which is invoked
   * when there is feedback matching the subscription query.
   *
   * @param {Array|string} path - Path to subscribe to
   * @param {function} listener - Listener invoked on feedback
   */


  _createClass(Feedback, [{
    key: 'on',
    value: function on(path, listener) {
      var _this = this;

      _log2.default.info('new feedback listener on: ' + path);
      var eventPath = (0, _normalizePath2.default)(path).join('/').toLowerCase();

      this.eventEmitter.on(eventPath, listener);

      var registration = this.xapi.execute('xFeedback/Subscribe', {
        Query: (0, _normalizePath2.default)(path)
      });

      var off = function off() {
        registration.then(function (_ref) {
          var Id = _ref.Id;

          _this.xapi.execute('xFeedback/Unsubscribe', { Id: Id });
        });

        _this.eventEmitter.removeListener(eventPath, listener);
      };

      return off;
    }

    /**
     * Registers a feedback listener similar to {@link on}, but the subscription
     * is removed after the first invocation of the listener.
     *
     * @param {Array|string} path - Path to subscribe to
     * @param {function} listener - Listener invoked on feedback
     */

  }, {
    key: 'once',
    value: function once(path, listener) {
      var _this2 = this;

      var off = void 0;
      var wrapped = function wrapped() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (typeof off === 'function') off();
        listener.call.apply(listener, [_this2].concat(args));
      };
      wrapped.listener = listener;
      off = this.on(path, wrapped);
      return off;
    }

    /**
     * Remove feedback registration.
     *
     * @deprecated use deactivation handler from `.on()` and `.once()` instead.
     */
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: 'off',
    value: function off() {
      throw new Error('.off() is deprecated. Use return value deactivate handler from .on() instead.');
    }

    /**
     * Dispatches feedback data to the registered handlers.
     *
     * @param {Object} data - JSON data structure of feedback data.
     * @return {FeedbackHandler} - Returns self for chaining.
     */

  }, {
    key: 'dispatch',
    value: function dispatch(data) {
      var _this3 = this;

      this.interceptor(data, function () {
        var d = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : data;
        return _dispatch(_this3, d);
      });
      return this;
    }

    /**
     * Creates a grouper object which tracks which tracks the feedback paths and
     * listeners being added to it.
     *
     * @return {FeedbackGroup} - Proxy object for xapi.feedback
     *
     * @example <caption>Bundle feedback listeners for easy unsubscription</caption>
     * // Create a group
     * const group = xapi.feedback.group([
     *   xapi.status.on('Audio Volume', (volume) => {
     *     // ...
     *   }),
     *   xapi.config.on('Audio DefaultVolume', (volume) => {
     *     // ...
     *   }),
     * ]);
     *
     * const handler = xapi.status.on('Call', (call) => { ... });
     *
     * // Add handler to the group
     * group.add(handler);
     *
     * // Remove handler from the group
     * group.remove(handler);
     *
     * // Unregister from all feedback handlers
     * group.off();
     */
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: 'group',
    value: function group(handlers) {
      return new FeedbackGroup(handlers);
    }
  }]);

  return Feedback;
}();

exports.default = Feedback;