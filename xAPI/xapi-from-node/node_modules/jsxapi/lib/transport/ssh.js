'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = connectSSH;

var _duplexPassthrough = require('duplex-passthrough');

var _duplexPassthrough2 = _interopRequireDefault(_duplexPassthrough);

var _ssh = require('ssh2');

var _log = require('../log');

var _log2 = _interopRequireDefault(_log);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * Patch DuplexPassThrough.prototype.on to always return "this".
 * For some event types it delegates and return the return value of
 * the contained reader/writer instances.
 */
if (!_duplexPassthrough2.default.prototype.on.isPatched) {
  var origOn = _duplexPassthrough2.default.prototype.on;
  var patchedFunc = function on() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    origOn.call.apply(origOn, [this].concat(args));
    return this;
  };
  patchedFunc.isPatched = true;
  _duplexPassthrough2.default.prototype.on = patchedFunc;
  _duplexPassthrough2.default.prototype.addListener = patchedFunc;
}

/**
 * Creates a {@link Duplex} SSH stream.
 *
 * @param {object} options
 * @param {string} options.host - Hostname or IP address.
 * @param {number} options.port - Port to connect to.
 * @param {string} options.username - Username used in authentication.
 * @param {string} options.password - Password used in authentication.
 * @param {string} options.command
 * - If command is specified, it is executed on the remote host instead of a login shell.
 * @return {Duplex} - SSH stream.
 */
function connectSSH(options) {
  var closing = false;

  var mergedOpts = Object.assign({
    client: new _ssh.Client(),
    transport: new _duplexPassthrough2.default()
  }, options);

  var client = mergedOpts.client,
      password = mergedOpts.password,
      transport = mergedOpts.transport;

  delete mergedOpts.password;

  function onKeyboardInteractive(n, i, il, p, finish) {
    finish([password]);
  }

  function onReady() {
    _log2.default.debug('[SSH] connection ready');
    client.shell(false, function (err, sshStream) {
      if (err) {
        _log2.default.error('[SSH] shell error:', err);
        transport.emit('error', err);
        return;
      }

      _log2.default.debug('[SSH] shell ready');
      sshStream.on('error', function (error) {
        transport.emit('error', error);
      }).on('end', function () {
        if (!closing) {
          transport.emit('error', 'Connection terminated remotely');
        }
      }).on('close', function () {
        transport.emit('close');
      });

      if (options.command) {
        client.exec(options.command, function (binaryErr, binaryStream) {
          if (binaryErr) {
            _log2.default.error('[SSH] exec error:', err);
            transport.emit('error', binaryErr);
            return;
          }
          binaryStream.on('error', function (error) {
            _log2.default.error('[SSH] stream error:', error);
            transport.emit('error', error);
          });
          _log2.default.debug('[SSH] exec ready');
          transport.wrapStream(binaryStream);
        });
        return;
      }

      transport.wrapStream(sshStream);
    });
  }

  client.on('keyboard-interactive', onKeyboardInteractive).on('ready', onReady).on('error', function (error) {
    transport.emit('error', error.level);
  }).on('close', function () {
    transport.emit('close');
  }).connect(Object.assign({ tryKeyboard: true }, mergedOpts));

  transport.close = function () {
    closing = true;
    client.end();
  };

  return transport;
}